class SFZEditor {
  constructor() {
    this.currentSFZ = null;
    this.regions = [];
    this.globalSettings = {};
    this.groups = [];
  }

  // Parse SFZ file content into structured data
  parseSFZ(sfzContent) {
    if (!sfzContent) {
      throw new Error('No SFZ content provided');
    }

    this.regions = [];
    this.groups = [];
    this.globalSettings = {};

    const lines = sfzContent.split('\n');
    let currentSection = null;
    let currentObject = null;

    for (let line of lines) {
      // Remove comments and trim
      line = line.replace(/\/\/.*$/, '').trim();
      if (!line) continue;

      // Check for section headers
      if (line.startsWith('<') && line.endsWith('>')) {
        const sectionName = line.slice(1, -1).toLowerCase();

        if (sectionName === 'global') {
          currentSection = 'global';
          currentObject = this.globalSettings;
        } else if (sectionName === 'group') {
          currentSection = 'group';
          currentObject = {};
          this.groups.push(currentObject);
        } else if (sectionName === 'region') {
          currentSection = 'region';
          currentObject = {};
          // Inherit group settings if exists
          if (this.groups.length > 0) {
            Object.assign(currentObject, this.groups[this.groups.length - 1]);
          }
          // Inherit global settings
          Object.assign(currentObject, this.globalSettings);
          this.regions.push(currentObject);
        } else if (sectionName === 'control') {
          currentSection = 'control';
          currentObject = {};
        }
      } else if (currentObject) {
        // Parse opcodes (key=value pairs)
        const opcodes = this.parseOpcodes(line);
        Object.assign(currentObject, opcodes);
      }
    }

    return {
      global: this.globalSettings,
      groups: this.groups,
      regions: this.regions
    };
  }

  // Parse SFZ opcodes from a line
  parseOpcodes(line) {
    const opcodes = {};
    // Split by spaces but respect quoted strings
    const pairs = line.match(/\S+="[^"]+"|[^\s]+/g) || [];

    for (const pair of pairs) {
      const [key, ...valueParts] = pair.split('=');
      if (valueParts.length > 0) {
        let value = valueParts.join('=');
        // Remove quotes if present
        if (value.startsWith('"') && value.endsWith('"')) {
          value = value.slice(1, -1);
        }
        opcodes[key] = this.parseValue(value);
      }
    }

    return opcodes;
  }

  // Parse value to appropriate type
  parseValue(value) {
    // Check for numeric value
    if (/^-?\d+$/.test(value)) {
      return parseInt(value, 10);
    }
    if (/^-?\d*\.\d+$/.test(value)) {
      return parseFloat(value);
    }
    return value;
  }

  // Generate SFZ content from structured data
  generateSFZ(sfzData = null) {
    if (!sfzData) {
      sfzData = {
        global: this.globalSettings,
        groups: this.groups,
        regions: this.regions
      };
    }

    let content = '';

    // Add header comment
    content += '// SFZ file generated by OTTO Drum Mapping System\n';
    content += `// Generated: ${new Date().toISOString()}\n\n`;

    // Global section
    if (sfzData.global && Object.keys(sfzData.global).length > 0) {
      content += '<global>\n';
      content += this.formatOpcodes(sfzData.global);
      content += '\n';
    }

    // Groups
    for (const group of sfzData.groups || []) {
      content += '<group>\n';
      content += this.formatOpcodes(group);
      content += '\n';
    }

    // Regions
    for (const region of sfzData.regions || []) {
      content += '<region>\n';
      content += this.formatOpcodes(region);
      content += '\n';
    }

    return content;
  }

  // Format opcodes for SFZ output
  formatOpcodes(opcodes) {
    let result = '';
    for (const [key, value] of Object.entries(opcodes)) {
      // Skip inherited group properties that shouldn't be duplicated
      if (key.startsWith('_')) continue;

      if (typeof value === 'string' && value.includes(' ')) {
        result += `${key}="${value}"\n`;
      } else {
        result += `${key}=${value}\n`;
      }
    }
    return result;
  }

  // Add or update a region
  addRegion(region) {
    // Ensure required fields
    if (!region.sample) {
      throw new Error('Region must have a sample');
    }

    // Set defaults if not provided
    const defaults = {
      key: region.key || 60, // Middle C if not specified
      lovel: region.lovel || 0,
      hivel: region.hivel || 127,
      pitch_keycenter: region.pitch_keycenter || region.key
    };

    const newRegion = { ...defaults, ...region };
    this.regions.push(newRegion);
    return newRegion;
  }

  // Remove a region by index or matching criteria
  removeRegion(criteria) {
    if (typeof criteria === 'number') {
      // Remove by index
      this.regions.splice(criteria, 1);
    } else if (typeof criteria === 'object') {
      // Remove matching regions
      this.regions = this.regions.filter(region => {
        for (const [key, value] of Object.entries(criteria)) {
          if (region[key] !== value) return true;
        }
        return false;
      });
    }
  }

  // Update regions matching criteria
  updateRegions(criteria, updates) {
    let updated = 0;
    this.regions.forEach(region => {
      let matches = true;
      for (const [key, value] of Object.entries(criteria)) {
        if (region[key] !== value) {
          matches = false;
          break;
        }
      }
      if (matches) {
        Object.assign(region, updates);
        updated++;
      }
    });
    return updated;
  }

  // Get regions for a specific MIDI note
  getRegionsForNote(note) {
    return this.regions.filter(region => {
      const keyLow = region.lokey || region.key || 0;
      const keyHigh = region.hikey || region.key || 127;
      return note >= keyLow && note <= keyHigh;
    });
  }

  // Get regions for a specific velocity
  getRegionsForVelocity(velocity) {
    return this.regions.filter(region => {
      const velLow = region.lovel || 0;
      const velHigh = region.hivel || 127;
      return velocity >= velLow && velocity <= velHigh;
    });
  }

  // Get regions for a specific note and velocity
  getRegionsForNoteAndVelocity(note, velocity) {
    return this.regions.filter(region => {
      const keyLow = region.lokey || region.key || 0;
      const keyHigh = region.hikey || region.key || 127;
      const velLow = region.lovel || 0;
      const velHigh = region.hivel || 127;

      return note >= keyLow && note <= keyHigh &&
             velocity >= velLow && velocity <= velHigh;
    });
  }

  // Map a drum sound to a MIDI note
  mapDrumToNote(drumSound, note, velocityLayers = null) {
    // Remove existing mappings for this note
    this.removeRegion({ key: note });

    if (velocityLayers && velocityLayers.length > 0) {
      // Add velocity layers
      velocityLayers.forEach(layer => {
        this.addRegion({
          sample: layer.sample || drumSound,
          key: note,
          lovel: layer.min || 0,
          hivel: layer.max || 127,
          pitch_keycenter: note, // Prevent pitch shifting
          loop_mode: 'one_shot' // Drums are typically one-shot
        });
      });
    } else {
      // Single layer
      this.addRegion({
        sample: drumSound,
        key: note,
        pitch_keycenter: note,
        loop_mode: 'one_shot'
      });
    }
  }

  // Add round-robin samples
  addRoundRobin(note, samples, velocity = null) {
    const regions = [];
    const seqLength = samples.length;

    samples.forEach((sample, index) => {
      const region = {
        sample: sample,
        key: note,
        pitch_keycenter: note,
        loop_mode: 'one_shot',
        seq_length: seqLength,
        seq_position: index + 1 // SFZ uses 1-based indexing
      };

      if (velocity) {
        region.lovel = velocity.min || 0;
        region.hivel = velocity.max || 127;
      }

      regions.push(this.addRegion(region));
    });

    return regions;
  }

  // Set global amp envelope
  setGlobalEnvelope(attack = 0, decay = 0, sustain = 100, release = 0.1) {
    this.globalSettings.ampeg_attack = attack;
    this.globalSettings.ampeg_decay = decay;
    this.globalSettings.ampeg_sustain = sustain;
    this.globalSettings.ampeg_release = release;
  }

  // Set global filter
  setGlobalFilter(type = 'lpf_2p', cutoff = 20000, resonance = 0) {
    this.globalSettings.fil_type = type;
    this.globalSettings.cutoff = cutoff;
    this.globalSettings.resonance = resonance;
  }

  // Add effects to global settings
  addGlobalEffect(effect, value) {
    const effectOpcodes = {
      reverb: 'reverb',
      chorus: 'chorus',
      delay: 'delay',
      pan: 'pan',
      volume: 'volume',
      tune: 'tune',
      transpose: 'transpose'
    };

    if (effectOpcodes[effect]) {
      this.globalSettings[effectOpcodes[effect]] = value;
    }
  }

  // Convert to drumkit-specific SFZ
  convertToDrumkit(drumMap) {
    const drumkitSFZ = {
      global: {
        ...this.globalSettings,
        loop_mode: 'one_shot', // Drums don't loop
        ampeg_release: 0.5, // Short release for drums
      },
      groups: [],
      regions: []
    };

    // Process each note in the drum map
    Object.entries(drumMap.mapping).forEach(([note, drumInfo]) => {
      if (drumInfo.velocityLayers && drumInfo.velocityLayers.length > 0) {
        // Add velocity layers
        drumInfo.velocityLayers.forEach(layer => {
          drumkitSFZ.regions.push({
            sample: layer.sample,
            key: parseInt(note),
            lokey: parseInt(note),
            hikey: parseInt(note),
            pitch_keycenter: parseInt(note),
            lovel: layer.min,
            hivel: layer.max,
            loop_mode: 'one_shot'
          });
        });
      } else if (drumInfo.samplePath) {
        // Single sample
        drumkitSFZ.regions.push({
          sample: drumInfo.samplePath,
          key: parseInt(note),
          lokey: parseInt(note),
          hikey: parseInt(note),
          pitch_keycenter: parseInt(note),
          loop_mode: 'one_shot'
        });
      }
    });

    return drumkitSFZ;
  }

  // Validate SFZ structure
  validate() {
    const errors = [];
    const warnings = [];

    // Check regions
    if (this.regions.length === 0) {
      errors.push('No regions defined');
    }

    this.regions.forEach((region, index) => {
      // Check for required opcodes
      if (!region.sample) {
        errors.push(`Region ${index}: Missing sample`);
      }

      // Check key range
      if (region.key !== undefined) {
        if (region.key < 0 || region.key > 127) {
          errors.push(`Region ${index}: Invalid key value ${region.key}`);
        }
      }

      // Check velocity range
      if (region.lovel !== undefined && (region.lovel < 0 || region.lovel > 127)) {
        errors.push(`Region ${index}: Invalid lovel value ${region.lovel}`);
      }
      if (region.hivel !== undefined && (region.hivel < 0 || region.hivel > 127)) {
        errors.push(`Region ${index}: Invalid hivel value ${region.hivel}`);
      }

      // Warnings for best practices
      if (!region.pitch_keycenter && region.key) {
        warnings.push(`Region ${index}: No pitch_keycenter defined, sample may be pitch-shifted`);
      }
    });

    return { valid: errors.length === 0, errors, warnings };
  }

  // Clone current SFZ data
  clone() {
    const clone = new SFZEditor();
    clone.globalSettings = { ...this.globalSettings };
    clone.groups = this.groups.map(g => ({ ...g }));
    clone.regions = this.regions.map(r => ({ ...r }));
    return clone;
  }

  // Clear all data
  clear() {
    this.regions = [];
    this.groups = [];
    this.globalSettings = {};
  }

  // Export as JSON for storage
  toJSON() {
    return {
      global: this.globalSettings,
      groups: this.groups,
      regions: this.regions
    };
  }

  // Import from JSON
  fromJSON(json) {
    if (typeof json === 'string') {
      json = JSON.parse(json);
    }
    this.globalSettings = json.global || {};
    this.groups = json.groups || [];
    this.regions = json.regions || [];
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = SFZEditor;
}